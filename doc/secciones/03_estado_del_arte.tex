\chapter{The State of the Art}
In this chapter we will analyze the most recent advances and promising ideas about distributed evolutionary algorithms and web technologies.

\section{Distributed Evolutionary Algorithms}
Introduction (cite paper here). We will explain the different distributed models and its advantages and disadvantages

Speak here also about dimension-distributed and Population-distributed 

(Place paper table here comparing them)

\subsection{Master-Slave}

It is a centralized model where one node has the role of master and the rest of slaves.
The master owns the entire population and is in charge of applying the genetic operators of selection, crossover, mutation, and replacement. The slaves, on the other hand, do not know about other slaves and are in charge of evaluating the fitness of the chromosomes in the population of the master.

The fitness function must require the majority of the computing load, otherwise, a non-distributed approach will outperform this model since the communication between the master and its slaves will be a bottleneck. 

In order to to apply this model to problems where the fitness function computational cost is not high enough, recent researches suggest to distribute other operators such as the crossover or mutation \cite{ismail}, or applying local search on slaves \cite{zhang2}. 

Another way to deal with this kind of problems is having a subpopulation in each slave; it will apply all the genetic operators and will communicate the best chromosomes within its population to the master. The master will be in charge of sending the best chromosomes to all its slaves.\cite{zhang1}

Although this model is simple and therefore easy to prototype, it has important limitations. The master's performance and communication time limits the performance scalability of this model \cite{erick}. Also, even though this model is fault tolerant across slaves (a failing slave can be replaced by a working one), the master still represents a single point of failure in this approach.

\subsection{Island}

Traditional evolutionary algorithms suffer from premature convergence problems when all chromosomes are around the same local optima. In this model, global search is improved with a rather simple design.

A population is divided into as many subpopulations as processors. Chromosomes migrate from one island to another at a set interval, this is equivalent to the selection operator in the source island and replacement in the destination one.

All islands should end up having the best solution so far within their subpopulations. This can be achieved either synchronously after an specific number of generations \cite{89}, or asynchronously when it is ready \cite{30}. Whereas the synchronous approach is simpler, the asynchronous approach is more flexible and can achieve better efficiency.

An important design decision for a island distributed EA is the topology of the islands. Whitley et al \cite{140} conducted an experiment where all islands were fully connected without using any kind of topology. They found that if the migration is conducted among all islands, the algorithm achieves almost the same results as a sequential execution. In recent years, different network topologies for island models have been being studies. Network topologies such as ring, torus, or layered have achieved superior performance in different experiments. \cite{62}

Scalability of this model is limited since performance highly depends on the number of islands and its resulting granularity \cite{58}. However, it has a good partition-tolerance since, although a failing island means a lost important portion of the entire population, it does not have any single-point of failure.

\subsection{Cellular}
In this model the entire population is distributed across all processors. Ideally one chromosome per processor. Communication between processors is defined by a network topology where chromosomes can only compete and mate with its neighbors.

If this model follows a synchronous approach, all cells update their chromosome simultaneously. Otherwise, cells update their chromosomes one by one asynchronously.

Alba et al. \cite{2} compared asynchronous and synchronous cellular-based models, solving discrete and continuous problems. They found that for discrete problems, asynchronous are more efficient, whereas synchronous find solutions with better fitness. For continuous problems, the opposite happened.

The topology plays an essential role in this mode as well. In \cite{68}, experimental results shown that for simple problems a regular topology (with high mean degree distribution) achieves better results. On the other hand, for complex problems a more complex network with high clustering coefficient is preferred.

Also, the ratio between the neighborhood radius and the topology radius plays a similar role as the topology itself. For simple problems a higher ratio achieves better results, whereas for complex problems a low ratio is preferred.\cite{5}

\subsection{Hierarchical}
Also known as Hybrid models, they combine different distributed models in order to take advantage of the problem-solving and scalability capabilities of the models they are made of.

\paragraph*{Island \& Master-Slave.} The population is split into several subpopulations across different master nodes. At the same time, these subpopulations will be islands where periodically chromosomes will migrate from one master node to another. A master sends chromosomes from its island to its own slaves, which will evaluate the chromosome fitness function.

This model addresses the scalability shortcoming of the island-based model as well as avoids the single point of failure that the unique master server represented. Moreover, the speedup of this hybrid model is relatively linear \cite{13}.

\paragraph*{Island \& cellular} Multiple processors that store a cells each one, are combined into groups of cells that will behave as islands. The quality of the solutions this model finds are comparable to classical distributed models but it provides better scalability and fault-tolerance.

\paragraph*{Island \& Island} When processors in island-model model are heterogeneous, but the model itself is homogeneous (all islands share the same settings of operators, control parameters, fitness evaluations, etc...), slower processors will slow-down the entire algorithm execution. Furthermore, a homogeneous model may not keep a proper balance between exploitation and exploration.  

Heterogeneus island models are being developed in order to address that issue. Sefrioui et al \cite{112}. designed a layered island model of three layers where the first layer was in charge of exploiting the already explored solution space, the second layer balanced exploitation and exploration, and the third one was fully-exploratory.

According to Herrera et al \cite{57}, local and global migration methods are a key issue in these hierarchical models since these methods establish the actual hierarchy between the layers. This approach achieved promising results in Herrera's hierarchical design approach, improving efficiency and collaboration. 

\subsection{Pool}

\textbf{How it works}

\textbf{Requirements}

\textbf{Advantages}

\textbf{Disadvantages}

\subsection{Coevolution}

\textbf{How it works}

\textbf{Requirements}

\textbf{Advantages}

\textbf{Disadvantages}

\subsection{Multi-agent}

\textbf{How it works}

\textbf{Requirements}

\textbf{Advantages}

\textbf{Disadvantages}

\section{Web Technologies}
Speak about JS and mention some frameworks (React, angular, Vue...)

\subsection{Web Assembly}
Mention that before wasm you had to either spend a lot ofmore computation time in the browser with JS or do it faster in the backend. Now you can use wasm to run computation-intense tasks in the client.

Speak about how it works.